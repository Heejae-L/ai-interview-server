<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>AI ëª¨ì˜ ë©´ì ‘ ì‹œìŠ¤í…œ</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    h2 { margin-top: 40px; }
    input[type="file"], textarea { margin-bottom: 10px; }
    button { margin-top: 5px; padding: 5px 10px; }
    pre { width: 100%; min-height: 100px; margin-top: 10px; white-space: pre-wrap; }
    #videoElement { width: 480px; height: 360px; background: #eee; margin-top: 10px; }
  </style>
</head>
<body>

  <h1>ğŸ§  AI ëª¨ì˜ ë©´ì ‘ ì‹œìŠ¤í…œ</h1>

  <!-- 1. ì´ë ¥ì„œ ë¶„ì„ -->
  <h2>1. ì´ë ¥ì„œ ë¶„ì„</h2>
  <input type="file" id="resumeFile">
  <button onclick="uploadResume()">ë¶„ì„</button>
  <pre id="resumeResult"></pre>

  <!-- 2. ì§ˆë¬¸ ìƒì„± -->
  <h2>2. ì§ˆë¬¸ ìƒì„±</h2>
  <input type="file" id="resumeForQuestions">
  <button onclick="generateQuestions()">ì§ˆë¬¸ ìƒì„±</button>
  <ol id="questionList"></ol>

  <!-- 3. ì¸í„°ë·° ì˜ìƒ ë…¹í™” -->
  <h2>3. ì¸í„°ë·° ì˜ìƒ ë…¹í™”</h2>
  <button onclick="startRecording()">ë…¹í™” ì‹œì‘</button>
  <button onclick="stopRecordingAndUpload()">ë…¹í™” ì¢…ë£Œ ë° ì˜ìƒ ì—…ë¡œë“œ</button>
  <video id="videoElement" autoplay muted></video>

  <!-- 4. ì§ˆë¬¸ ìŒì„± ì¶œë ¥ -->
  <h2>4. ì§ˆë¬¸ ìŒì„± ì¶œë ¥</h2>
  <button onclick="speakQuestions()">ì§ˆë¬¸ ì½ê¸°</button>

  <!-- 5. í¬ì¦ˆ ë¶„ì„ ê²°ê³¼ -->
  <h2>5. í¬ì¦ˆ ë¶„ì„ ê²°ê³¼</h2>
  <pre id="log"></pre>

  <!-- 6. ìŒì„± STT ë° ë©”íŠ¸ë¦­ìŠ¤ -->
  <h2>6. ìŒì„± STT ë° ë©”íŠ¸ë¦­ìŠ¤</h2>
  <input type="file" id="audioFile">
  <button onclick="transcribeAudio()">STT ë³€í™˜</button>
  <pre id="transcriptResult"></pre>
  <button onclick="getAudioMetrics()">ì˜¤ë””ì˜¤ ë©”íŠ¸ë¦­ìŠ¤</button>
  <pre id="audioMetricsResult"></pre>

  <!-- 7. ë©´ì ‘ í‰ê°€ -->
  <h2>7. ë©´ì ‘ í‰ê°€</h2>
  <textarea id="textAnswers" placeholder="ê° ì§ˆë¬¸ì— ëŒ€í•œ í…ìŠ¤íŠ¸ ë‹µë³€ì„ ì¤„ë°”ê¿ˆí•˜ì—¬ ì…ë ¥"></textarea>
  <input type="file" id="evaluationAudioFiles" multiple>
  <button onclick="evaluateInterview()">í‰ê°€</button>
  <pre id="evaluationResult"></pre>

  <!-- 8. ë©´ì ‘ í”Œë¡œìš° -->
  <h2>8. ë©´ì ‘ í”Œë¡œìš°</h2>
  <button onclick="interviewFlow()">ë©´ì ‘ ì‹œì‘</button>

  <script>
    let generatedQuestions = [];

    async function uploadResume() {
      const fileEl = document.getElementById('resumeFile');
      if (!fileEl.files.length) return alert('ì´ë ¥ì„œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
      const form = new FormData();
      form.append('file', fileEl.files[0]);
      const res = await fetch('/parse_resume', { method: 'POST', body: form });
      const data = await res.json();
      document.getElementById('resumeResult').textContent = JSON.stringify(data, null, 2);
    }

    async function generateQuestions() {
      const fileEl = document.getElementById('resumeForQuestions');
      if (!fileEl.files.length) return alert('ì´ë ¥ì„œë¥¼ ì„ íƒí•˜ì„¸ìš”.');
      const form = new FormData();
      form.append('file', fileEl.files[0]);
      const res = await fetch('/generate_questions', { method: 'POST', body: form });
      const data = await res.json();
      generatedQuestions = data.questions;
      const list = document.getElementById('questionList');
      list.innerHTML = '';
      generatedQuestions.forEach(q => {
        const li = document.createElement('li');
        li.textContent = q;
        list.appendChild(li);
      });
    }

    async function startRecording() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
      document.getElementById('videoElement').srcObject = stream;
      window._mediaRecorder = new MediaRecorder(stream);
      window._mediaRecorder.ondataavailable = e => {
        if (!window._chunks) window._chunks = [];
        window._chunks.push(e.data);
      };
      window._mediaRecorder.start();
      alert('ë…¹í™” ì‹œì‘ë¨');
    }

    function stopRecordingAndUpload() {
      if (!window._mediaRecorder) return alert('ë¨¼ì € ë…¹í™”ë¥¼ ì‹œì‘í•˜ì„¸ìš”.');
      window._mediaRecorder.stop();
      window._mediaRecorder.onstop = async () => {
        const blob = new Blob(window._chunks, { type: 'video/webm' });
        const form = new FormData();
        form.append('file', blob, 'interview_recording.webm');
        const res = await fetch('/pose/analyze', { method: 'POST', body: form });
        const text = await res.text();
        document.getElementById('log').textContent += text;
        alert('ì˜ìƒ ì—…ë¡œë“œ ë° ë¶„ì„ ì™„ë£Œ');
      };
    }

    function speakQuestions() {
      if (!generatedQuestions.length) return alert('ë¨¼ì € ì§ˆë¬¸ì„ ìƒì„±í•˜ì„¸ìš”.');
      const utter = new SpeechSynthesisUtterance(generatedQuestions.join('. ë‹¤ìŒ ì§ˆë¬¸. '));
      utter.lang = 'ko-KR';
      speechSynthesis.speak(utter);
    }

    async function transcribeAudio() {
      const fileEl = document.getElementById('audioFile');
      if (!fileEl.files.length) return alert('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
      const form = new FormData();
      form.append('file', fileEl.files[0]);
      const res = await fetch('/transcribe', { method: 'POST', body: form });
      const data = await res.json();
      document.getElementById('transcriptResult').textContent = JSON.stringify(data, null, 2);
    }

    async function getAudioMetrics() {
      const fileEl = document.getElementById('audioFile');
      if (!fileEl.files.length) return alert('ì˜¤ë””ì˜¤ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”.');
      const form = new FormData();
      form.append('file', fileEl.files[0]);
      const res = await fetch('/audio_metrics', { method: 'POST', body: form });
      const data = await res.json();
      document.getElementById('audioMetricsResult').textContent = JSON.stringify(data, null, 2);
    }

    async function recordAndTranscribe() {
      const res = await fetch('/audio/record_and_transcribe', { method: 'POST' });
      if (!res.ok) throw new Error('ë…¹ìŒ ë° ì „ì‚¬ ì‹¤íŒ¨');
      return res.json();
    }

    async function interviewFlow() {
      if (!generatedQuestions.length) return alert('ë¨¼ì € ì§ˆë¬¸ì„ ìƒì„±í•˜ì„¸ìš”.');
      const qas = [];
      await fetch('/video/start', { method: 'POST' });
      for (let i = 0; i < generatedQuestions.length; i++) {
        const q = generatedQuestions[i];
        const utt = new SpeechSynthesisUtterance(q);
        utt.lang = 'ko-KR';
        await new Promise(resolve => { utt.onend = resolve; speechSynthesis.speak(utt); });
        document.getElementById('log').textContent = `Q${i+1}: ${q}\në‹µë³€ ë…¹ìŒ ì¤‘...`;
        let result;
        try {
          result = await recordAndTranscribe();
        } catch (e) {
          alert(e.message);
          break;
        }
        const ans = Array.isArray(result.word_timestamps)
          ? result.word_timestamps.map(w => w.word).join(' ')
          : '';
        qas.push({ question: q, answer: ans });
        if (ans.includes('ê·¸ë§Œí•˜ê² ìŠµë‹ˆë‹¤')) break;
        document.getElementById('log').textContent += `\nì‚¬ìš©ì ë‹µë³€: ${ans}`;
      }
      await fetch('/video/stop', { method: 'POST' });
      document.getElementById('log').textContent += '\nì˜ìƒ ë…¹í™” ì¢…ë£Œ';

      // í‰ê°€ í˜¸ì¶œ (/evaluateë¡œ ë³€ê²½)
      const form = new FormData();
      qas.forEach(item => form.append('questions', item.question));
      qas.forEach(item => form.append('answers', item.answer));
      const res = await fetch('/evaluate', { method: 'POST', body: form });
      const text = await res.text();
      document.getElementById('evaluationResult').textContent = text;
    }

    async function evaluateInterview() {
      const form = new FormData();
      document.getElementById('questionList').querySelectorAll('li').forEach(li => form.append('questions', li.textContent));
      document.getElementById('textAnswers').value.split('\n').forEach(a => form.append('answers', a));
      const filesEl = document.getElementById('evaluationAudioFiles');
      Array.from(filesEl.files).forEach(f => form.append('audio_files', f));
      const res = await fetch('/evaluate', { method: 'POST', body: form });
      const text = await res.text();
      document.getElementById('evaluationResult').textContent = text;
    }
  </script>
</body>
</html>
